/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Inject, Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { BehaviorSubject, Subject, of as observableOf, from as observableFrom, combineLatest } from 'rxjs';
import { filter, switchMap, switchMapTo, take } from 'rxjs/operators';
import { LoaderService } from './loader.service';
import { CONFIG } from './types/config.token';
import { CONSTANTS } from './types/constants.enum';
export class TranslateService {
    /**
     * @param {?} http
     * @param {?} config
     */
    constructor(http, config) {
        this.http = http;
        this.config = config;
        this.translations = {};
        this.translationsLoaded = new BehaviorSubject(false);
        this.matcher = key => new RegExp('{{\\s?[\\b' + key + '\\b]*\\s?}}', 'gm');
        this.loaderService = new LoaderService(http, config);
    }
    /**
     * @return {?}
     */
    getBrowserLanguage() {
        let /** @type {?} */ browserLanguage = window.navigator.languages
            ? window.navigator.languages[0]
            : window.navigator.language;
        if (browserLanguage.indexOf('-') !== -1) {
            browserLanguage = browserLanguage.split('-')[0];
        }
        if (browserLanguage.indexOf('_') !== -1) {
            browserLanguage = browserLanguage.split('_')[0];
        }
        return browserLanguage;
    }
    /**
     * @param {?} fileName
     * @return {?}
     */
    setDefault(fileName) {
        this.defaultKey = fileName;
        this.defaultPrefix = fileName.split('-')[0];
        if (this.translations[this.defaultKey]) {
            this.translationsLoaded.next(true);
        }
        else {
            this.translationsLoaded.next(false);
            this.loaderService.getFile(fileName)
                .subscribe(translations => {
                this.translations[this.defaultKey] = translations;
                this.translationsLoaded.next(true);
            });
        }
    }
    /**
     * @param {?} fileName
     * @return {?}
     */
    setOverride(fileName) {
        this.overrideKey = fileName;
        if (this.translations[this.overrideKey]) {
            this.translationsLoaded.next(true);
        }
        else {
            this.loaderService.getFile(fileName)
                .subscribe(translations => {
                this.translations[this.overrideKey] = translations;
                this.translationsLoaded.next(true);
            });
        }
    }
    /**
     * @param {?} keyPaths
     * @return {?}
     */
    get(keyPaths) {
        return this.translationsLoaded.pipe(filter(Boolean), switchMapTo(keyPaths instanceof Array
            ? this.getAll(keyPaths)
            : this.getOne(keyPaths)));
    }
    /**
     * @param {?} keyPaths
     * @param {?} fileName
     * @return {?}
     */
    getByFileName(keyPaths, fileName) {
        const /** @type {?} */ translationLoaded = new Subject();
        const /** @type {?} */ defaultFileName = `${this.defaultPrefix}-${fileName.split('-')[1]}`;
        this.loaderService.getFile(fileName).pipe(file => combineLatest(file, this.loaderService.getFile(defaultFileName)), filter(([file, defaultFile]) => [file, defaultFile].indexOf(undefined) === -1), take(1)).subscribe(([translations, defaultTranslations]) => {
            this.translations[fileName] = translations;
            this.translations[defaultFileName] = defaultTranslations;
            translationLoaded.next(fileName);
        }, () => {
            this.loaderService.getFile(defaultFileName)
                .pipe(take(1))
                .subscribe(translations => {
                this.translations[defaultFileName] = translations;
                translationLoaded.next(defaultFileName);
            });
        });
        return translationLoaded.pipe(switchMap(overrideFileName => keyPaths instanceof Array
            ? this.getAll(keyPaths, overrideFileName, defaultFileName)
            : this.getOne(keyPaths, overrideFileName, defaultFileName)));
    }
    /**
     * @param {?} keyPath
     * @param {?=} fileName
     * @param {?=} defaultKey
     * @return {?}
     */
    getOne(keyPath, fileName = this.overrideKey, defaultKey = this.defaultKey) {
        return observableFrom([this.read(keyPath, {}, fileName, defaultKey)]);
    }
    /**
     * @param {?} keyPaths
     * @param {?=} fileName
     * @param {?=} defaultKey
     * @return {?}
     */
    getAll(keyPaths, fileName = this.overrideKey, defaultKey = this.defaultKey) {
        return observableOf(keyPaths.reduce((acc, keyPath) => (Object.assign({}, acc, { [keyPath]: this.read(keyPath, {}, fileName, defaultKey) })), {}));
    }
    /**
     * @param {?} keyPath
     * @param {?=} params
     * @param {?=} overrideKey
     * @param {?=} defaultKey
     * @return {?}
     */
    read(keyPath, params = {}, overrideKey = this.overrideKey, defaultKey = this.defaultKey) {
        let /** @type {?} */ value = CONSTANTS.EXIT;
        const /** @type {?} */ path = keyPath.split('.');
        if (this.translations[overrideKey]) {
            value = this.readValue(path, this.translations[overrideKey]);
            if (value === CONSTANTS.EXIT) {
                value = this.readValue(path, this.translations[defaultKey]);
            }
        }
        else if (this.translations[defaultKey]) {
            value = this.readValue(path, this.translations[defaultKey]);
        }
        if (Boolean(params) && params !== {}) {
            value = Object.keys(params)
                .reduce((final, key) => final.replace(this.matcher(key), params[key]), value);
        }
        if (value === CONSTANTS.EXIT) {
            console.warn('Unknown Key: ', keyPath);
            return keyPath;
        }
        return value;
    }
    /**
     * @param {?} path
     * @param {?} translation
     * @return {?}
     */
    readValue(path, translation) {
        const /** @type {?} */ length = path.length;
        for (let /** @type {?} */ i = 0; i < length; i++) {
            translation = translation && translation[path[i]] ? translation[path[i]] : CONSTANTS.EXIT;
            if (translation === CONSTANTS.EXIT) {
                break;
            }
        }
        return translation;
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    isEquivalent(a, b) {
        if (!Boolean(a) || !Boolean(b)) {
            return false;
        }
        const /** @type {?} */ aProps = Object.getOwnPropertyNames(a);
        const /** @type {?} */ bProps = Object.getOwnPropertyNames(b);
        if (aProps.length !== bProps.length) {
            return false;
        }
        for (let /** @type {?} */ i = 0; i < aProps.length; i++) {
            const /** @type {?} */ propName = aProps[i];
            if (a[propName] !== b[propName]) {
                return false;
            }
        }
        return true;
    }
}
TranslateService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
TranslateService.ctorParameters = () => [
    { type: HttpClient, },
    { type: undefined, decorators: [{ type: Inject, args: [CONFIG,] },] },
];
function TranslateService_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    TranslateService.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    TranslateService.ctorParameters;
    /** @type {?} */
    TranslateService.prototype.defaultKey;
    /** @type {?} */
    TranslateService.prototype.defaultPrefix;
    /** @type {?} */
    TranslateService.prototype.overrideKey;
    /** @type {?} */
    TranslateService.prototype.translations;
    /** @type {?} */
    TranslateService.prototype.loaderService;
    /** @type {?} */
    TranslateService.prototype.translationsLoaded;
    /** @type {?} */
    TranslateService.prototype.matcher;
    /** @type {?} */
    TranslateService.prototype.http;
    /** @type {?} */
    TranslateService.prototype.config;
}
//# sourceMappingURL=translate.service.js.map